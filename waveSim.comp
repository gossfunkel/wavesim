#version 430

uniform float sys_scale;

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

#pragma include "common.glsl"

//uniform float osg_FrameTime;
//uniform float osg_DeltaFrameTime;
uniform int osg_FrameNumber;

//in vec4 p3d_Color; // SSBO used instead of these shader inputs
//in float scale;

// mathematical constants (precompiled; used in functions)
const float pi = 3.141592653589793238462643383;
const float pi_sqrt = sqrt(pi);
const float oneOverRt4Pi = 1./(2*pi_sqrt);
const float sqrt34pi = sqrt(3./(4.*pi));
const float halfRt15pi = sqrt(15./pi)/2.;
const float quartRt5pi = sqrt(5./pi)/4.;
const float halfRt3pi = sqrt(3./pi)/2.;
float piConstants[6]; // index constants based on pi to array (must be populated at runtime)

//const float oneOverRt2 = 1./sqrt(2.);
const float oneOverRt24 = 1./sqrt(24.);
const float twoOverRt27 = 2./sqrt(27.);
const float eightOver27rt6 = 8. / (27 * sqrt(6.));
const float fourOver81rt30 = 4. / (81 * sqrt(30.));
float numConstants[6]; // index numerical constants to array (must be populated at runtime)

float sphericalHarmonic (vec3 r, float phase, float dist, uint l, int m) { 
	return phase/360 + pow(piConstants[3],min(max(l-1,0),1)) * piConstants[l] 
					* (pow(r.x,clamp(max(m,0),0,1)+clamp(-1-m,0,1)) 
					* pow(r.y,clamp(-1 * min(m,0),0,1))
					* ((3*max(clamp(max(l-1,0),0,1) - clamp(m*m,0,1),0))*pow(r.z,l-abs(m)))
					+ pow(r.x,min(max(m-1,0),1)) - pow(r.y*r.y*r.y,min(max(m-1,0),1)) 
					- (dist*dist*max(clamp(max(l-1,0),0,1) - clamp(m*m,0,1),0)) )/pow(dist,l);
}

float radial (float r, uint n, uint l) {
	return pow(4-n,4) * (numConstants[n-1 + max(n-2,0)] 
				* (1/pow(r,(n-1)-l) - ((n-1)-l)/(n* (n-1) * pow(r,(n-2) + l)) + (n-1)/(n*n*pow(r,n-3))) 
				* pow(r,n-1) * exp((-1. * r)/n));
}

void main() {
	uint n = 3; // n is a whole number, and tells us the energy level of the function
	uint l = 2; // l is a natural number < n, and tells us the geometry of the function
	int m = 0; // |m| <= l, and tells us which configuration of the function this is
	// quantum number ms is not handled here. What do you expect of me?!?

	piConstants[0] = oneOverRt4Pi; 
	piConstants[1] = sqrt34pi;
	piConstants[2] = halfRt15pi;
	piConstants[3] = halfRt3pi;

	numConstants[0] = 2.;
	numConstants[1] = 0.25;
	numConstants[2] = oneOverRt24;
	numConstants[3] = twoOverRt27;
	numConstants[4] = eightOver27rt6;
	numConstants[5] = fourOver81rt30;

	uint dataPointId = gl_GlobalInvocationID.x;

	vec3 pos = dataPoints[dataPointId].pos.xyz;

	// n.b. this is only required due to the coordinate system; if the origin was at the centre, we would not need this
	vec3 r = vec3(pos.x-sys_scale/2,pos.y-sys_scale/2,pos.z-sys_scale/2);
	vec3 midpoint = vec3(sys_scale/2,sys_scale/2,sys_scale/2);
	float dist = sqrt(r.x*r.x + r.y*r.y + r.z*r.z);

	float frameNum = float(osg_FrameNumber)/4.;// * osg_DeltaFrameTime;
	//float frameNum = 0.;

	float pointPhase = sphericalHarmonic(r, mod(frameNum,360.), dist, l, m);
	float pointPhaseInv = sphericalHarmonic(r, mod(frameNum+180.,360.), dist, l, m);
	float radialVal = clamp(radial(dist, n, l),-1.,1.);

	float radPosComp = max(radialVal, 0.);
	float radNegComp = -1 * min(radialVal, 0.);

	vec4 col = vec4(((4*pointPhase - .5)-(4*pointPhase - .5)*(4*pointPhase - .5))+1., 
				((4*pointPhase - 1.5)-(4*pointPhase - 1.5)*(4*pointPhase - 1.5))+1.,
				((4*pointPhase - 2.5)-(4*pointPhase - 2.5)*(4*pointPhase - 2.5))+1.,
				radPosComp * dataPoints[dataPointId].size); // set transparency equal to the absolute value of the radial func, product with the scale
	vec4 colInv = vec4(((4*pointPhaseInv - .5)-(4*pointPhaseInv - .5)*(4*pointPhaseInv - .5))+1., 
				((4*pointPhaseInv - 1.5)-(4*pointPhaseInv - 1.5)*(4*pointPhaseInv - 1.5))+1.,
				((4*pointPhaseInv - 2.5)-(4*pointPhaseInv - 2.5)*(4*pointPhaseInv - 2.5))+1.,
				radNegComp * dataPoints[dataPointId].size); 
	//dataPoints[dataPointId].col.x = col.x * radPosComp + colInv.x * radNegComp;
	//dataPoints[dataPointId].col.y = col.y * radPosComp + colInv.y * radNegComp;
	//dataPoints[dataPointId].col.z = col.z * radPosComp + colInv.z * radNegComp;
	dataPoints[dataPointId].col.x = 1;
	dataPoints[dataPointId].col.y = 1;
	dataPoints[dataPointId].col.z = 1;
	dataPoints[dataPointId].col.w = 1;

}