#version 430

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

#pragma include "common.glsl"

//uniform float osg_FrameTime;
//uniform float osg_DeltaFrameTime;
uniform float osg_FrameTime;
uniform float sys_scale;

//in vec4 p3d_Color; // SSBO used instead of these shader inputs
//in float scale;

// mathematical constants (precompiled; used in functions)
const float pi = 3.141592653589793238462643383;
const float pi_sqrt = sqrt(pi);
const float oneOverRt4Pi = 1./(2*pi_sqrt);
const float sqrt34pi = sqrt(3./(4.*pi));
const float halfRt15pi = sqrt(15./pi)/2.;
const float quartRt5pi = sqrt(5./pi)/4.;
const float halfRt3pi = sqrt(3./pi)/2.;
float piConstants[6]; // index constants based on pi to array (must be populated at runtime)

//const float oneOverRt2 = 1./sqrt(2.);
const float oneOverRt24 = 1./sqrt(24.);
const float twoOverRt27 = 2./sqrt(27.);
const float eightOver27rt6 = 8. / (27 * sqrt(6.));
const float fourOver81rt30 = 4. / (81 * sqrt(30.));
float numConstants[6]; // index numerical constants to array (must be populated at runtime)

float sphericalHarmonic (vec3 r, float phase, float dist, uint l, int m) { 
	return phase/360 + pow(piConstants[3],min(max(l-1,0),1)) * piConstants[l] 
					* (pow(r.x,clamp(max(m,0),0,1)+clamp(-1-m,0,1)) 
					* pow(r.y,clamp(-1 * min(m,0),0,1))
					* ((3*max(clamp(max(l-1,0),0,1) - clamp(m*m,0,1),0))*pow(r.z,l-abs(m)))
					+ pow(r.x,min(max(m-1,0),1)) - pow(r.y*r.y*r.y,min(max(m-1,0),1)) 
					- (dist*dist*max(clamp(max(l-1,0),0,1) - clamp(m*m,0,1),0)) )/pow(dist,l);
}

float radial (float r, uint n, uint l) {
	return pow(4-n,4) * (numConstants[n-1 + max(n-2,0)] 
				* (1/pow(r,(n-1)-l) - ((n-1)-l)/(n* (n-1) * pow(r,(n-2) + l)) + (n-1)/(n*n*pow(r,n-3))) 
				* pow(r,n-1) * exp((-1. * r)/n));
}

/*vec3 colourSpectrum (float val) {
	return vec3(R,
				G,
				B);
}*/

void main() {
	uint n = 1; // n is a whole number, and tells us the energy level of the function
	uint l = 0; // l is a natural number < n, and tells us the geometry of the function
	int m = 0; // |m| <= l, and tells us which configuration of the function this is
	// quantum number ms is not handled here. What do you expect of me?!?

	piConstants[0] = oneOverRt4Pi; 
	piConstants[1] = sqrt34pi;
	piConstants[2] = halfRt15pi;
	piConstants[3] = halfRt3pi;

	numConstants[0] = 2.;
	numConstants[1] = 0.25;
	numConstants[2] = oneOverRt24;
	numConstants[3] = twoOverRt27;
	numConstants[4] = eightOver27rt6;
	numConstants[5] = fourOver81rt30;

	uint dataPointId = gl_GlobalInvocationID.x;

	vec3 pos = dataPoints[dataPointId].pos.xyz;
	float size = dataPoints[dataPointId].size;

	// n.b. this is only required due to the coordinate system; if the origin was at the centre, we would not need this
	vec3 r = vec3(pos.x-sys_scale/2,pos.y-sys_scale/2,pos.z-sys_scale/2);
	vec3 midpoint = vec3(sys_scale/2,sys_scale/2,sys_scale/2);
	float dist = sqrt(r.x*r.x + r.y*r.y + r.z*r.z);

	float frameNum = float(osg_FrameTime)/4.;// * osg_DeltaFrameTime;
	//float frameNum = 0.;

	//float pointVal = sphericalHarmonic(r, mod(frameNum,360.), dist, l, m);
	float pointVal = fract(.25+.25*abs(sin(frameNum)));
	//float pointValInv = sphericalHarmonic(r, mod(frameNum+180.,360.), dist, l, m);
	float pointValInv = cos(1. + frameNum);
	//float radialVal = 4*clamp(radial(dist, n, l),-1.,1.);
	float radialVal = 1;

	float radPosComp = max(radialVal, 0.);
	float radNegComp = -1 * min(radialVal, 0.);

	vec4 col = vec4(((4*pointVal - .5)-(4*pointVal - .5)*(4*pointVal - .5))+1., 
				((4*pointVal - 1.5)-(4*pointVal - 1.5)*(4*pointVal - 1.5))+1.,
				((4*pointVal - 2.5)-(4*pointVal - 2.5)*(4*pointVal - 2.5))+1.,
				radialVal * size); // set transparency equal to the absolute value of the radial func, product with the scale
	col.x = col.x * radPosComp + radNegComp * (((4*pointValInv - .5 ) - (4*pointValInv - .5 ) * (4*pointValInv - .5 )) +1.); 
	col.y = col.y * radPosComp + radNegComp * (((4*pointValInv - 1.5) - (4*pointValInv - 1.5) * (4*pointValInv - 1.5)) +1.),
	col.z = col.z * radPosComp + radNegComp * (((4*pointValInv - 2.5) - (4*pointValInv - 2.5) * (4*pointValInv - 2.5)) +1.),
	dataPoints[dataPointId].col = col;
	//dataPoints[dataPointId].col.x = 1;
	//dataPoints[dataPointId].col.y = 1;
	//dataPoints[dataPointId].col.z = 1;
	//dataPoints[dataPointId].col.w = 1;

}